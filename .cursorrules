# Project Structure
```
.
├── 01_network/          # ネットワーク関連のTerraformコード
│   ├── vpc/            # VPCの設定ファイル
│   └── env/            # 環境別の設定
│       └── stg/        # ステージング環境の設定
│
├── 02_ec2/             # EC2インスタンス関連のTerraformコード
│
├── terraform-backend/   # Terraformのバックエンド設定
│
├── .vscode/            # VSCode設定ファイル
│
└── .terraform/         # Terraformの一時ファイル *[ignore]* 
```

# Terraform Rules and Best Practices

## File Structure
- 各モジュールには以下のファイルを含める:
  - `main.tf`: リソース定義
  - `variables.tf`: 変数定義
  - `outputs.tf`: 出力値定義
  - `versions.tf`: プロバイダーとバージョン定義
  - `locals.tf`: ローカル変数定義（必要な場合）

## Naming Conventions
- リソース名: スネークケース (`example_resource`)
- 変数名: スネークケース (`vpc_cidr`)
- タグ: キャメルケース (`Environment`, `Name`)
- ファイル名: スネークケース (`main.tf`, `vpc_config.tf`)

## Code Style
- インデントは2スペース
- リソースブロックは論理的にグループ化
- コメントは必要な箇所に適切に追加
- 各リソースには最低限以下のタグを付与:
  - `Name`
  - `Environment`
  - `ManagedBy: Terraform`

## Tag Rules
- 必須タグ:
  - `Name`: リソースの一意な識別子
  - `Environment`: 環境名 (`Dev`, `Stg`, `Prod`)
  - `ManagedBy`: 管理ツール名 (`Terraform`)
- 推奨タグ:
  - `Description`: リソースの説明
- タグの命名規則:
  - キー: キャメルケース
  - 値: 一貫性のある形式を使用
- タグの実装:
  ```hcl
  locals {
    common_tags = {
      Environment  = var.environment
      Project     = var.project_name
      ManagedBy   = "Terraform"
      Owner       = var.owner
      CostCenter  = var.cost_center
    }
  }
  ```

## Security
- シークレット情報は直接コードに記述しない
- AWS Secrets ManagerまたはSSMパラメータストアを使用
- セキュリティグループは最小権限の原則に従う

## State Management
- リモートステートを使用 (S3)
- ステートファイルはワークスペース/環境ごとに分離
- ステートのバックアップを有効化

## Module Structure
- 再利用可能なモジュールは汎用的に設計
- モジュールは単一責任の原則に従う
- 必須パラメータは適切なバリデーションを実装

## Version Control
- `.terraform/` ディレクトリは.gitignoreに含める
- `*.tfstate` ファイルはバージョン管理対象外
- `*.tfvars` ファイルは機密情報を含む場合は管理対象外 

## Commit Rules
- コミットメッセージは以下の形式に従う:
  ```
  <type>(<scope>): <description>

  [optional body]
  ```
- type は以下のいずれかを使用:
  - `feat`: 新機能
  - `fix`: バグ修正
  - `refactor`: リファクタリング
  - `docs`: ドキュメントのみの変更
  - `style`: コードの意味に影響しない変更（空白、フォーマット等）
  - `test`: テストコードの追加・修正
  - `chore`: ビルドプロセスやツールの変更
- scope はオプションで、変更が影響する範囲を示す（例: vpc, ec2）
- description は変更内容を簡潔に説明する
- 本文は必要な場合のみ追加し、変更の詳細な説明を記載

### コミットの粒度に関するルール
- 1つのコミットは1つの論理的な変更のみを含める
- 以下の場合は必ず別々のコミットとする:
  - 異なるモジュールへの変更（例: VPCとEC2の変更は分ける）
  - 異なる環境への変更（例: stgとprodの変更は分ける）
  - 異なる目的の変更（例: リファクタリングと機能追加は分ける）
  - ドキュメントの更新と実装の変更
- コミットの目安となる単位:
  - 新規機能の追加: 機能単位でコミット
  - リファクタリング: 変更の影響範囲ごとにコミット
  - バグ修正: 修正対象ごとにコミット
  - 設定変更: 設定項目の種類ごとにコミット
- 以下の場合は同じコミットにまとめても良い:
  - 同一モジュール内の関連する複数の小さな変更
  - テストコードと実装コードの追加（ただし、既存のテストの修正は分ける）
  - 同一の目的で行う複数の軽微な変更
- コミットの大きさの目安:
  - 変更行数が100行を超える場合は、分割できないか検討する
  - 複数のファイルを変更する場合は、論理的なまとまりで分割する
- 作業途中のコミット:
  - 作業途中でも、論理的な区切りでコミットする
  - 未完成の機能は必ずfeatureブランチで作業する
  - WIP（Work In Progress）コミットは避け、完結した変更単位でコミットする
- コミットメッセージは日本語で記述すること

## インフラを触るときの注意
- インフラを触るときは必ずterraform planを実行して、変更内容を確認すること
- 作業終了の前にプロジェクト全体の整合性がおかしくなっていないかを確認すること


